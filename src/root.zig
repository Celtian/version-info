//! By convention, root.zig is the root source file when making a library.
const std = @import("std");

const Color = struct {
    pub const RESET = "\x1b[0m";
    pub const BOLD = "\x1b[1m";
    pub const RED = "\x1b[31m";
    pub const GREEN = "\x1b[32m";
    pub const YELLOW = "\x1b[33m";
    pub const BLUE = "\x1b[34m";
    pub const MAGENTA = "\x1b[35m";
    pub const CYAN = "\x1b[36m";
    pub const WHITE = "\x1b[37m";
    pub const BRIGHT_GREEN = "\x1b[92m";
    pub const BRIGHT_BLUE = "\x1b[94m";
    pub const BRIGHT_MAGENTA = "\x1b[95m";
    pub const BRIGHT_CYAN = "\x1b[96m";
};

/// Helper function for colored logging
fn log(comptime color: []const u8, comptime emoji: []const u8, comptime fmt: []const u8, args: anytype) void {
    std.debug.print("{s}" ++ emoji ++ " " ++ fmt ++ "{s}\n", .{color} ++ args ++ .{Color.RESET});
}

/// Helper function for printing empty line
fn logNewLine() void {
    std.debug.print("\n", .{});
}

/// Prints version from package.json in a nicely formatted way
pub fn printVersion(allocator: std.mem.Allocator, package_json_path: []const u8) !void {
    const file = try std.fs.cwd().openFile(package_json_path, .{});
    defer file.close();

    const file_content = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(file_content);

    const parsed = try std.json.parseFromSlice(std.json.Value, allocator, file_content, .{});
    defer parsed.deinit();

    const version = parsed.value.object.get("version").?.string;
    logNewLine();
    log(Color.BRIGHT_CYAN, "üì¶", "Version: {s}", .{version});
    logNewLine();
}

fn writeTypescriptHeader(writer: anytype) !void {
    try writer.writeAll("/**\n");
    try writer.writeAll(" * Generated by script üç∫\n");
    try writer.writeAll(" * Do not edit manually.\n");
    try writer.writeAll(" */\n\n");
}

/// Writes the VERSION_INFO export statement to the output
fn writeVersionInfo(writer: anytype, version: []const u8, date_str: []const u8) !void {
    try writer.print("export const VERSION_INFO = {{\n", .{});
    try writer.print("  version: \"{s}\",\n", .{version});
    try writer.print("  date: \"{s}\"\n", .{date_str});
    try writer.print("}};\n", .{});
}

/// Formats a Unix timestamp in milliseconds to ISO 8601 format (YYYY-MM-DDTHH:MM:SS.sssZ)
fn formatTimestampISO8601(buffer: []u8, millis: i64) ![]const u8 {
    const seconds = @divTrunc(millis, 1000);
    const ms = @mod(millis, 1000);

    // Calculate date components from Unix timestamp
    const seconds_per_day: i64 = 86400;
    const days_since_epoch = @divTrunc(seconds, seconds_per_day);
    const seconds_today = @mod(seconds, seconds_per_day);

    // Unix epoch is 1970-01-01, which is day 719468 in the proleptic Gregorian calendar
    const days_from_0 = days_since_epoch + 719468;

    // Calculate year, month, day using algorithm
    const era = @divTrunc(days_from_0, 146097);
    const doe = @mod(days_from_0, 146097);
    const yoe = @divTrunc(doe - @divTrunc(doe, 1460) + @divTrunc(doe, 36524) - @divTrunc(doe, 146096), 365);
    const y = yoe + era * 400;
    const doy = doe - (365 * yoe + @divTrunc(yoe, 4) - @divTrunc(yoe, 100));
    const mp = @divTrunc(5 * doy + 2, 153);
    const d = doy - @divTrunc(153 * mp + 2, 5) + 1;
    const m = if (mp < 10) mp + 3 else mp - 9;
    const year = if (m <= 2) y + 1 else y;

    const hours = @divTrunc(seconds_today, 3600);
    const minutes = @divTrunc(@mod(seconds_today, 3600), 60);
    const secs = @mod(seconds_today, 60);

    return try std.fmt.bufPrint(buffer, "{d:0>4}-{d:0>2}-{d:0>2}T{d:0>2}:{d:0>2}:{d:0>2}.{d:0>3}Z", .{
        @as(u32, @intCast(year)),  @as(u32, @intCast(m)),       @as(u32, @intCast(d)),
        @as(u32, @intCast(hours)), @as(u32, @intCast(minutes)), @as(u32, @intCast(secs)),
        @as(u32, @intCast(ms)),
    });
}

/// Generates a version-info.ts file from package.json
pub fn generateVersionInfo(allocator: std.mem.Allocator, package_json_path: []const u8, output_path: []const u8) !void {
    const start_time = std.time.milliTimestamp();
    logNewLine();
    log(Color.YELLOW, "üöÄ", "Starting version info generation...", .{});

    logNewLine();
    log(Color.BLUE, "üìñ", "Reading {s}...", .{package_json_path});
    const file = try std.fs.cwd().openFile(package_json_path, .{});
    defer file.close();

    const file_content = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(file_content);

    const parsed = try std.json.parseFromSlice(std.json.Value, allocator, file_content, .{});
    defer parsed.deinit();

    const version = parsed.value.object.get("version").?.string;
    log(Color.BLUE, "üì¶", "Version: {s}", .{version});

    logNewLine();
    log(Color.MAGENTA, "‚è∞", "Generating timestamp...", .{});
    const millis = std.time.milliTimestamp();
    var date_buffer: [30]u8 = undefined;
    const date_str = try formatTimestampISO8601(&date_buffer, millis);
    log(Color.MAGENTA, "üìÖ", "Date: {s}", .{date_str});

    logNewLine();
    log(Color.BRIGHT_GREEN, "‚úçÔ∏è ", "Writing to {s}...", .{output_path});

    // Ensure parent directory exists
    if (std.fs.path.dirname(output_path)) |dir_path| {
        try std.fs.cwd().makePath(dir_path);
    }

    const output_file = try std.fs.cwd().createFile(output_path, .{});
    defer output_file.close();

    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = output_file.writer(&stdout_buffer);
    const writer = &stdout_writer.interface;

    try writeTypescriptHeader(writer);
    try writeVersionInfo(writer, version, date_str);

    try writer.flush();

    const end_time = std.time.milliTimestamp();
    const duration_ms = end_time - start_time;
    log(Color.BRIGHT_GREEN, "‚úÖ", "Successfully generated {s}!", .{output_path});
    logNewLine();
    log(Color.YELLOW, "‚è±Ô∏è ", "Duration: {d}ms", .{duration_ms});
    logNewLine();
}
